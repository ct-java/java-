[toc]
# 线程面试
## 什么是线程？
线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。Java在语言层面对多线程提供了卓越的支持，它也是一个很好的卖点。
## 线程和进程有什么区别？
- 进程：一个计算机程序的运行实例，包含了需要执行的指令；有自己的独立地址空间，包含程序内容和数据；不同进程的地址空间是互相隔离的；进程拥有各种资源和状态信息，包括打开的文件、子进程和信号处理。
- 线程：表示程序的执行流程，是CPU调度执行的基本单位；线程有自己的程序计数器、寄存器、堆栈和帧。同一进程中的线程共用相同的地址空间，同时共享进程所拥有的内存和其他资源。
- 线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。
> - Java标准库提供了进程和线程相关的API，进程主要包括表示进程的java.lang.Process类和创建进程的java.lang.ProcessBuilder类
> - 表示线程的是java.lang.Thread类，在虚拟机启动之后，通常只有Java类的main方法这个普通线程运行，运行时可以创建和启动新的线程；还有一类守护线程（damon thread）,守护线程在后台运行，提供程序运行时所需要的服务。当虚拟机中运行的所有线程都是守护线程时，虚拟机终止运行。

## java提供的线程同步方式
### 1.synchronized关键字
方法或代码块的互斥性来完成实际上的一个原子操作。（方法或代码块在被一个线程调用时，其他线程处于等待状态）
所有的Java对象都有一个与synchronzied关联的监视器对象（monitor），允许线程在该监视器对象上进行加锁和解锁操作。
- 静态方法：Java类对应的Class类的对象所关联的监视器对象
- 实例方法：当前对象实例所关联的监视器对象
- 代码块：代码块声明中的对象所关联的监视器对象
注：当锁被释放，对共享变量的修改会写入主存；当活得锁，CPU缓存中的内容被置为无效。编译器在处理synchronized方法或代码块，不会把其中包含的代码移动到synchronized方法或代码块之外，从而避免了由于代码重排而造成的问题
### 2.Object类的wait、notify和notifyAll方法
生产者和消费者模式，判断缓冲区是否满来消费，缓冲区是否空来生产的逻辑。如果用while 和 volatile也可以做，不过本质上会让线程处于忙等待，占用CPU时间，对性能造成影响。
- wait：将当前线程放入，该对象的等待池中，线程A调用了B对象的wait()方法，线程A进入B对象的等待池，并且释放B的锁。（这里，线程A必须持有B的锁，所以调用的代码必须在synchronized修饰下，否则直接抛出java.lang.IllegalMonitorStateException异常）。
- notify：将该对象中等待池中的线程，随机选取一个放入对象的锁池，当当前线程结束后释放掉锁， 锁池中的线程即可竞争对象的锁来获得执行机会。
- notifyAll：将对象中等待池中的线程，全部放入锁池。
（notify锁唤醒的线程选择由虚拟机实现来决定，不能保证一个对象锁关联的等待集合中的线程按照所期望的顺序被唤醒，很可能一个线程被唤醒之后，发现他所要求的条件并没有满足，而重新进入等待池。因为当等待池中包含多个线程时，一般使用notifyAll方法，不过该方法会导致线程在没有必要的情况下被唤醒，之后又马上进入等待池，对性能有影响，不过能保证程序的正确性）
==工作流程：==
1. Consumer线程A 来 看产品，发现产品为空，调用产品对象的wait()，线程A进入产品对象的等待池并释放产品的锁
2. Producer线程B获得产品的锁，执行产品的notifyAll()，Consumer线程A从产品的等待池进入锁池，Producer线程B生产产品，然后退出释放锁
3. Consumer线程A获得产品锁，进入执行，发现有产品，消费产品，然后退出
```Java
public synchronized String pop(){
  this.notifyAll();// 唤醒对象等待池中的所有线程，可能唤醒的就是 生产者（当生产者发现产品满，就会进入对象的等待池，这里代码省略，基本略同）
   while(index == -1){//如果发现没产品，就释放锁，进入对象等待池
      this.wait();
   }//当生产者生产完后，消费者从this.wait()方法再开始执行，第一次还会执行循环，万一产品还是为空，则再等待，所以这里必须用while循环，不能用if
   String good = buffer[index];
   buffer[index] = null;
   index--;
   return good;// 消费完产品，退出。
}
```
注：wait()方法有超时和不超时之分，超时的在经过一段时间，线程还在对象的等待池中，那么线程也会推出等待状态
### 3.线程状态转换
![Thread状态转换](http://img.blog.csdn.net/20130828010551062)
==已经废弃的方法：stop、suspend、resume、destroy，这些方法在实现上时不安全的==
==线程的状态：NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING（有超时的等待）、TERMINATED==
- 方法sleep()进入的阻塞状态，不会释放对象的锁（即大家一起睡，谁也别想执行代码），所以不要让sleep方法处在synchronized方法或代码块中，否则造成其他等待获取锁的线程长时间处于等待
- 方法join()则是主线程等待子线程完成，再往下执行。例如main方法新建两个线程A和B
- 方法interrupt()，向被调用的对象线程发起中断请求。如线程A通过调用线程B的d的interrupt方法来发出中断请求，线程B来处理这个请求，当然也可以忽略，这不是必须的。Object类的wait()、Thread类的join()和sleep方法都会抛出受检异常java.lang.InterruptedException，通过interrupt方法中断该线程会导致线程离开等待状态。对于wait()调用来说，线程需要重新获取监视器对象上的锁之后才能抛出InterruptedException异常，并致以异常的处理逻辑
>可以通过Thread类的isInterrupted方法来判断是否有中断请求发生，通常可以利用这个方法来判断是否退出线程（类似上面的volatitle修饰符的例子）；
Thread类还有个方法Interrupted()，该方法不但可以判断当前线程是否被中断，还会清楚线程内部的中断标记，如果返回true，即曾被请求中断，同时调用完后，清除中断标记。
如果一个线程在某个对象的等待池，那么notify和interrupt 都可以使该线程从等待池中被移除。如果同时发生，那么看实际发生顺序。如果是notify先，那照常唤醒，没影响
- yield()，尝试让出所占有的CPU资源，让其他线程获取运行机会，对操作系统上的调度器来说是一个信号，不一定立即切换线程。（在实际开发中，测试阶段频繁调用yeid方法使线程切换更频繁，从而让一些多线程相关的错误更容易暴露出来）

## 非阻塞方式
- 线程之间同步机制的核心是监视对象上的锁，竞争锁来获得执行代码的机会。当一个对象获取对象的锁，然后其他尝试获取锁的对象会处于等待状态，这种锁机制的实现方式很大程度限制了多线程程序的吞吐量和性能（线程阻塞），且会带来死锁（线程A有a对象锁，等着获取b对象锁，线程B有b对象锁，等待获取a对象锁）和优先级倒置（优先级低的线程获得锁，优先级高的只能等待对方释放锁）等问题。
- 如果能不阻塞线程，又能保证多线程程序的正确性，就能有更好的性能。
- 在程序中，对共享变量的使用一般遵循一定的模式，即读取、修改和写入三步组成。之前碰到的问题是，这三步执行中可能线程执行切换，造成非原子操作。锁机制是把这三步变成一个原子操作。
- 目前CPU本身实现 将这三步 合起来形成一个原子操作，无需线程锁机制干预，常见的指令是“比较和替换”（compare and swap,CAS），这个指令会先比较某个内存地址的当前值是不是指定的旧指，如果是，就用新值替换，否则什么也不做，指令返回的结果是内存地址的当前值。通过CAS指令可以实现不依赖锁机制的非阻塞算法。一般做法是把CAS指令的调用放在一个无限循环中，不断尝试，知道CAS指令成功完成修改。
- java.util.concurrent.atomic包中提供了CAS指令。（不是所有CPU都支持CAS，在某些平台，java.util.concurrent.atomic的实现仍然是锁机制）
### atomic提供了Java相关的类
==类中的方法：==
1. 支持以原子操作来进行更新的数据类型的Java类（AtomicBoolean、AtomicInteger、AtomicReference），在内存模型相关的语义上，这四个类的对象类似于volatile变量
- compareAndSet：接受两个参数，一个是期望的旧值，一个是替换的新值
- weakCompareAndSet：效果同compareAndSet（JSR中表示weak原子方式读取和有条件地写入变量但不创建任何 happen-before 排序，但在源代码中和compareAndSet完全一样，所以并没有按JSR实现）
- get和set：分别用来直接获取和设置变量的值
- lazySet：与set类似，但允许编译器把lazySet方法的调用与后面的指令进行重排，因此对值得设置操作有可能被推迟
```Java
public class AtomicIdGenerator{
   private final AtomicInter counter = new AtomicInteger(0);
   public int getNext(){
      return counter.getAndIncrement();
   }
}
// getAndIncrement方法的内部实现方式，这也是CAS方法的一般模式，CAS方法不一定成功，所以包装在一个无限循环中，直到成功
public final int getAndIncrement(){
   for(;;){
      int current = get();
      int next = current +1;
      if(compareAndSet(current,next))
         return current;
   }
}
```
2. 提供对数组类型的变量进行处理的Java类，AtomicIntegerArray、AtomicLongArray和AtomicReferenceArray类。（同上，只是放在类数组里，调用时也只是多了一个操作元素索引的参数）
3. 通过反射的方式对任何对象中包含的volatitle变量使用CAS方法，AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater。他们提供了一种方式把CAS的功能扩展到了任何Java类中声明为volatitle的域上。（灵活，但语义较弱，因为对象的volatitle可能被非atomic的其他方式被修改）
```java
public class TreeNode{
   private volatile TreeNode parent;
// 静态工厂方法
private static final AtomicReferenceFieldUpdater<TreeNode, TreeNode> parentUpdater = AtomicReferenceFieldUpdater.newUpdater(TreeNode.class,TreeNode.class,"parent");
public boolean compareAndSetParent(TreeNode expect, TreeNode update){
      return parentUpdater.compareAndSet(this, expect, update);
}
}
```
## 高级同步机制（比synchronized更灵活的加锁机制）
- synchronized和volatile，以及wait、notify等方法抽象层次低，在程序开发中使用比较繁琐，易出错。
- 而多线程之间的交互来说，存在某些固定的模式，如生产者-消费者和读者-写者模式，把这些模式抽象成高层API，使用起来会非常方便。
- java.util.concurrent包为多线程提供了高层的API，满足日常开发中的常见需求
### 常用接口
1. Lock接口，表示一个锁方法：
- lock()，获取所，如果无法获取所锁，会处于等待状态
- unlock()，释放锁。（一般放在finally代码块中）
- lockInterruptibly()，与lock()类似，但允许当前线程在等待获取锁的过程中被中断。（所以要处理InterruptedException）
- tryLock()，以非阻塞方式获取锁，如果无法获取锁，则返回false。（tryLock()的另一个重载可以指定超时，如果指定超时，当无法获取锁，会等待而阻塞，同时线程可以被中断）
2. ReadWriteLock接口，表示两个锁，读取的共享锁和写入的排他锁。（适合常见的读者--写者场景）
- ReadWriteLock接口的readLock和writeLock方法来获取对应的锁的Lock接口的实现
- 在多数线程读取，少数线程写入的情况下，可以提高多线程的性能，提高使用该数据结构的吞吐量
- 如果是相反的情况，较多的线程写入，则接口会降低性能
3. ReentrantLock类和ReentrantReadWriteLock，分别为上面两个接口的实现类
他们具有重入性：即允许一个线程多次获取同一个锁（他们会记住上次获取锁并且未释放的线程对象，和加锁的次数，getHoldCount()）
同一个线程每次获取锁，加锁数+1，每次释放锁，加锁数-1，到0，则该锁被释放，可以被其他线程获取
```Java
public class LockIdGenrator{
//new ReentrantLock(true)是重载，使用更加公平的加锁机制，在锁被释放后，会优先给等待时间最长的线程，避免一些线程长期无法获得锁
   private int ReentrantLock lock = ReentrantLock();
   privafte int value = 0;
   public int getNext(){
      lock.lock();      //进来就加锁，没有锁会等待
      try{
         return value++;//实际操作
      }finally{
         lock.unlock();//释放锁
      }
   }
}
```
注：重入性减少了锁在各个线程之间的等待，例如便利一个HashMap，每次next()之前加锁，之后释放，可以保证一个线程一口气完成便利，而不会每次next()之后释放锁，然后和其他线程竞争，降低了加锁的代价， 提供了程序整体的吞吐量。（即，让一个线程一口气完成任务，再把锁传递给其他线程）
4. Condition接口，Lock接口代替了synchronized，Condition接口替代了object的wait、nofity
- await()，使当前线程进入等待状态，知道被唤醒或中断。重载形式可以指定超时时间
- awaitNanos()，以纳秒为单位等待
- awaitUntil()，指定超时发生的时间点，而不是经过的时间，参数为java.util.Date
- awaitUninterruptibly()，前面几种会响应其他线程发出的中断请求，他会无视，直到被唤醒
==注：与Object类的wait()相同，await()会释放其所持有的锁==
- signal()和signalAll， 相当于 notify和notifyAll
```Java
Lock lock = new ReentrantLock();
Condition condition = lock.newCondition();
lock.lock();
try{
   while(/*逻辑条件不满足*/){
      condition.await();   
   }
}finally{
   lock.unlock();
}
```
## 底层同步器
- 多线程程序中，线程之间存在多种不同的同步方式。除了Java标准库提供的同步方式之外，程序中特有的同步方式需要由开发人员自己来实现。
- 常见的一种需求是 对有限个共享资源的访问，比如多台个人电脑，2台打印机，当多个线程在等待同一个资源时，从公平角度出发，会用FIFO队列。
- 如果程序中的同步方式可以抽象成对有限个资源的访问，那么可以使用java.util.concurrent.locks包中的AbstractQueuedSynchronizer类和AbstractQueuedLongSynchronizer类作为实现的基础，前者用int类型的变量来维护内部状态，而后者用long类型。（可以将这个变量理解为共享资源个数）
- 通过getState、setState、和compareAndSetState3个方法更新内部变量的值。
- AbstractQueuedSynchronizer类是abstract的，需要覆盖其中包含的部分方法，通常做法是把其作为一个Java类的内部类，外部类提供具体的同步方式，内部类则作为实现的基础。有两种模式，排他模式和共享模式，分别对应方法 tryAcquire()、tryRelease 和 tryAcquireShared、tryReleaseShared，在这些方法中，使用getState、setState、compareAndSetState3个方法来修改内部变量的值，以此来反应资源的状态。

```Java
public class SimpleResourceManager{
   private final InnerSynchronizer synchronizer;
   private static class InnerSynchronizer extends AbstractQueuedSynchronizer{
      InnerSynchronizer(int numOfResources){
         setState(numOfResources);
      }
      protected int tryAcquireShared(int acquires){
         for(;;){
            int available = getState();
            int remain = available - acquires;
            if(remain <0 || comapreAndSetState(available, remain){
               return remain;
            }
         }
      }
      protected boolean try ReleaseShared(int releases){
         for(;;){
            int available = getState();
            int next = available + releases;
            if(compareAndSetState(available,next){
               return true;
            }
         }
      }
   }
   public SimpleResourceManager(int numOfResources){
      synchronizer = new InnerSynchronizer(numOfResources);
   }
   public void acquire() throws InterruptedException{
      synchronizer.acquireSharedInterruptibly(1);
   }      
   pubic void release(){    
      synchronizer.releaseShared(1);
    }
}
```

## 高级同步对象（提高开发效率）
atomic和locks包提供的Java类可以满足基本的互斥和同步访问的需求，但这些Java类的抽象层次较低，使用比较复杂。更简单的做法是使用java.util.concurrent包中的高级同步对象
### 1.信号量
信号量一般用来数量有限的资源，每类资源有一个对象的信号量，信号量的值表示资源的可用数量。
在使用资源时，需要从该信号量上获取许可，成功获取许可，资源的可用数-1；完成对资源的使用，释放许可，资源可用数+1； 当资源数为0时，需要获取资源的线程以阻塞的方式来等待资源，或过段时间之后再来检查资源是否可用。（上面的SimpleResourceManager类实际上时信号量的一个简单实现）
java.util.concurrent.Semaphore类，在创建Semaphore类的对象时指定资源的可用数
- acquire()，以阻塞方式获取许可
- tryAcquire()，以非阻塞方式获取许可
- release()，释放许可
- accquireUninterruptibly()，accquire()方法获取许可以的过程可以被中断，如果不希望被中断，使用此方法
```Java
public class PrinterManager{
   private final Semphore semaphore;
   private final List<Printer> printers = new ArrayList<>():
   public PrinterManager(Collection<? extends Printer> printers){
      this.printers.addAll(printers);
      //这里重载方法，第二个参数为true，以公平竞争模式，防止线程饥饿
      this.semaphore = new Semaphore(this.printers.size(),true);
   }
   public Printer acquirePrinter() throws InterruptedException{
      semaphore.acquire();
      return getAvailablePrinter();
   }
   public void releasePrinter(Printer printer){
      putBackPrinter(pinter);
      semaphore.release();
   }
   private synchronized Printer getAvailablePrinter(){
      printer result = printers.get(0);
      printers.remove(0);
      return result;
   }
   private synchronized void putBackPrinter(Printer printer){
      printers.add(printer);
   }
}
```
### 2.倒数闸门
多线程协作时，一个线程等待另外的线程完成任务才能继续进行。
java.util.concurrent.CountDownLatch类，创建该类时，指定等待完成的任务数；当一个任务完成，调用countDonw()，任务数-1。等待任务完成的线程通过await()，进入阻塞状态，直到任务数量为0。CountDownLatch类为一次性，一旦任务数为0，再调用await()不再阻塞当前线程，直接返回
```java

```
***
### 3.循环屏障
循环屏障在作用上类似倒数闸门，不过他不像倒数闸门是一次性的，可以循环使用。另外，线程之间是互相平等的，彼此都需要等待对方完成，当一个线程完成自己的任务之后，等待其他线程完成。当所有线程都完成任务之后，所有线程才可以继续运行。
当线程之间需要再次进行互相等待时，可以复用同一个循环屏障。
类java.uti.concurrent.CyclicBarrier用来表示循环屏障，创建时指定使用该对象的线程数目，还可以指定一个Runnable接口的对象作为每次循环后执行的动作。（当最后一个线程完成任务之后，所有线程继续执行之前，被执行。如果线程之间需要更新一些共享的内部状态，可以利用这个Runnalbe接口的对象来处理）。
每个线程任务完成之后，通过调用await方法进行等待，当所有线程都调用await方法之后，处于等待状态的线程都可以继续执行。在所有线程中，只要有一个在等待中被中断，超时或是其他错误，整个循环屏障会失败，所有等待中的其他线程抛出java.uti.concurrent.BrokenBarrierException。
例：每个线程负责找一个数字区间的质数，当所有线程完成后，如果质数数目不够，继续扩大范围查找
```Java
public class PrimeNumber{
   private static final int TOTAL_COUTN = 5000;
   private static final int RANGE_LENGTH= 200;
   private static final int WORKER_NUMBER = 5;
   private static volatitle boolean done = false;
   private static int rangeCount = 0;
   private static final List<Long> results = new ArrayList<Long>():
   private static final CyclicBarrier barrier = new CyclicBarrier(WORKER_NUMBER, new Runnable(){
      public void run(){
         if(results.size() >= TOTAL_COUNT){
            done = true;
         }
     }
   });
   private static class PrimeFinder implements Runnable{
      public void run(){
         while(!done){// 整个过程在一个 while循环下，await()等待，下次循环开始，会再次判断 执行条件
            int range = getNextRange();
            long start = rang * RANGE_LENGTH;
            long end = (range + 1) * RANGE_LENGTH;
            for(long i = start; i<end;i++){
               if(isPrime(i)){
                  updateResult(i);
               }
            }
            try{
               barrier.await();
            }catch (InterruptedException | BokenBarrierException e){
               done =  true;
            }
         }
      }
   }
   private synchronized static void updateResult(long value){
      results.add(value);
   }
   private synchronized static int getNextRange(){
      return rangeCount++;
   }
   private static boolean isPrime(long number){
      //找质数的代码
   }
   public void calculate(){
      for(int i=0;i<WORKER_NUMBER;i++){
         new Thread(new PrimeFinder()).start();
      }
      while(!done){

      }
      //计算完成
   }
}
```
### 4.对象交换器
适合于两个线程需要进行数据交换的场景。（一个线程完成后，把结果交给另一个线程继续处理）
java.util.concurrent.Exchanger类，提供了这种对象交换能力，两个线程共享一个Exchanger类的对象，一个线程完成对数据的处理之后，调用Exchanger类的exchange()方法把处理之后的数据作为参数发送给另外一个线程。而exchange方法的返回结果是另外一个线程锁提供的相同类型的对象。如果另外一个线程未完成对数据的处理，那么exchange()会使当前线程进入等待状态，直到另外一个线程也调用了exchange方法来进行数据交换。
```Java
public class SendAndReceiver{
   private final Exchanger<StringBuilder> exchanger = new Exchanger<StringBuilder>();
   private class Sender implements Runnable{
      public void run(){
         try{
            StringBuilder content = new StringBuilder("Hello");
            content = exchanger.exchange(content);
         }catch(InterruptedException e){
            Thread.currentThread().interrupt();
         }
      }
   }
   private class Receiver implements Runnable{
      public void run(){
         try{
            StringBuilder content = new StringBuilder("World");
            content = exchanger.exchange(content);
         }catch(InterruptedException e){
            Thread.currentThread().interrupt();
         }
      }
   }
   public void exchange(){
      new Thread(new Sender()).start();
      new Thread(new Receiver()).start();
   }
}
```

## 多线程程序使用的高性能数据结构
java.util.concurrent包中提供了一些适合多线程程序使用的高性能数据结构，包括队列和集合类对象等
### 1.队列
- BlockingQueue接口：线程安全的阻塞式队列；当队列已满时，想队列添加会阻塞；当队列空时，取数据会阻塞。（非常适合消费者-生产者模式）
阻塞方式：put()、take()。
非阻塞方式：offer()、poll()。
实现类：基于数组的固定元素个数的ArrayBolockingQueue和基于链表结构的不固定元素个数的LinkedBlockQueue类
- BlockingDeque接口： 与BlockingQueue相似，但可以对头尾进行添加和删除操作的双向队列；方法分为两类，分别在队首和对尾进行操作。
实现类：标准库值提供了一个基于链表的实现，LinkedBlockgingDeque
### 2.集合类
在多线程程序中，如果共享变量时集合类的对象，则不适合直接使用java.util包中的集合类。这些类要么不是线程安全，要么在多线程下性能比较差。
应该使用java.util.concurrent包中的集合类
- ConcurrentMap接口： 继承自java.util.Map接口
putIfAbsent()：只有在散列表不包含给定键时，才会把给定的值放入。
remove()：删除条目。
replace(key,value)：把value 替换到给定的key上。
replace(key, oldvalue, newvalue)：CAS的实现。
实现类：ConcurrentHashMap：
创建时，如果可以预估可能包含的条目个数，可以优化性能。（因为动态调整所能包含的数目操作比较耗时，这个HashMap也一样，只是多线程下更耗时）。
创建时，预估进行更新操作的线程数，这样实现中会根据这个数把内部空间划分为对应数量的部分。（默认是16，如果只有一个线程进行写操作，其他都是读取，那么把值设为1 可以提高性能）。
注：当从集合中创建出迭代器遍历Map元素时，不一定能看到正在添加的数据，只能和集合保证弱一致性。（当然使用迭代器不会因为查看正在改变的Map，而抛出java.util.ConcurrentModifycationException）
- CopyOnWriteArrayList接口：继承自java.util.List接口。
顾名思义，在CopyOnWriteArrayList的实现类，所有对列表的更新操作都会新创建一个底层数组的副本，并使用副本来存储数据；对列表更新操作加锁，读取操作不加锁。
适合多读取少修改的场景，如果更新操作多，那么不适合用，同样迭代器只能表示创建时列表的状态，更新后使用了新的底层数组，迭代器还是引用旧的底层数组

## 多线程任务的执行
过去线程的执行，是先创建Thread类的想，再调用start方法启动，这种做法要求开发人员对线程进行维护，在线程较多时，一般创建一个线程池同一管理，同时降低重复创建线程的开销
在J2SE5.0中，java.util.concurrent包提供了丰富的用来管理线程和执行任务的实现
### 1.基本接口（描述任务）
- Callable接口：Runnable接口受限于run方法的类型签名，而Callable只有一个方法call()，可以有返回值，可以抛出受检异常
- Future接口：过去，需要异步线程的任务执行结果，要求主线程和任务执行线程之间进行同步和数据传递。Future简化了任务的异步执行，作为异步操作的一个抽象。调用get()方法可以获取异步的执行结果，如果任务没有执行完，会等待，直到任务完成或被取消，cancel()可以取消
- Delayed接口：延迟执行任务，getDelay()返回当前剩余的延迟时间，如果不大于0，说明延迟时间已经过去，应该调度并执行该任务

### 2.组合接口（描述任务）
- RunnableFuture接口：继承自Runnable接口和Future接口。当来自Runnalbe接口中的run方法成功执行之后，相当于Future接口表示的异步任务已经完成，可以通过get()获取运行结果
- ScheduledFuture接口：继承Future接口和Delayed接口，表示一个可以调用的异步操作
- RunnableScheduledFuture接口：继承自Runnable、Delayed和Future，接口中包含isPeriodic，表明该异步操作是否可以被重复执行

### 3.Executor接口、ExcutorServer接口、ScheduleExecutorService接口和CompletionService接口（描述任务执行）
- executor接口，execute()用来执行一个Runnable接口的实现对象，不同的Executor实现采取不同执行策略，但提供的任务执行功能比较弱
- excutorServer接口，继承自executor；提供了对任务的管理：submit()，可以吧Callable和Runnable作为任务提交，得到一个Future作为返回，可以获取任务结果或取消任务。
提供批量执行：invokeAll()和invokeAny()，同时提交多个Callable；invokeAll()，会等待所有任务都执行完成，返回一个包含每个任务对应Future的列表；invokeAny()，任何一个任务成功完成，即返回该任务结果。
提供任务关闭：shutdown()、shutdownNow()来关闭服务，前者不允许新的任务提交，后者试图终止正在运行和等待的任务，并返回已经提交单没有被运行的任务列表。（两个方法都不会等待服务真正关闭，只是发出关闭请求。）。shutdownDow，通常做法是向线程发出中断请求，所以确保提交的任务实现了正确的中断处理逻辑
- ScheduleExecutorService接口，继承自excutorServer接口：支持任务的延迟执行和定期执行，可以执行Callable或Runnable。
schedule()，调度一个任务在延迟若干时间之后执行；
scheduleAtFixedRate()：在初始延迟后，每隔一段时间循环执行；在下一次执行开始时，上一次执行可能还未结束。（同一时间，可能有多个）
scheduleWithFixedDelay：同上，只是在上一次任务执行完后，经过给定的间隔时间再开始下一次执行。（同一时间，只有一个）
以上三个方法都返回ScheduledFuture接口的实现对象
- CompletionService接口，共享任务执行结果。
通常在使用ExecutorService接口，通过submit提交任务，并得到一个Future接口来获取任务结果，如果任务提交者和执行结果的使用者是程序的不同部分，那就要把Future在不同部分进行传递；而CompletionService就是解决这个问题，程序不同部分可以共享CompletionService，任务提交后，执行结果可以通过take（阻塞），poll（非阻塞）来获取。
标准库提供的实现是 ExecutorCompletionService，在创建时，需要提供一个Executor接口的实现作为参数，用来实际执行任务。
例：多线程方式下载文件
```Java
public class FileDownloader{
   // 线程池
   private final ExecutorService executor = Executors.newFixedThreadPool(10);
   public boolean download(final URL url, final Path path){
   Future<Path> future = executor.submit(new Callable<Path>(){ //submit提交任务
      public Path call(){
         //这里就省略IOException的处理了
         InputStream is = url.openStream();
         Files.copy(is, path, StandardCopyOption.REPLACE_EXISTING);
         return path;
      });
      try{
         return future.get() !=null ? true : false;
      }<span style="font-family: Arial, Helvetica, sans-serif;">catch(InterruptedException | ExecutionException e){</span>
             return false;
      }
   }
   public void close(){//当不再使用FileDownloader类的对象时，应该使用close方法关闭其中包含的ExecutorService接口的实现对象，否则虚拟机不会退出，占用内存不释放
      executor.shutdown();// 发出关闭请求，此时不会再接受新任务
      try{
         if(!executor.awaitTermination(3, TimeUnit.MINUTES)){// awaitTermination 来等待一段时间，使正在执行的任务或等待的任务有机会完成
            executor.shutdownNow();// 如果等待时间过后还有任务没完成，则强制结束
            executor.awaitTermination(1, TimeUnit.MINUTES);// 再等待一段时间，使被强制结束的任务完成必要的清理工作
         }
      }catch(InterruptedException e){
         executor.shutdownNow();
         Thread.currentThread().interrupt();
      }
   }
}
```
***
## Thread类中的start()和run()方法有什么区别?
1. tart()方法来启动线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码；通过调用Thread类的start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行操作的， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。
2. run()方法当作普通方法的方式调用。程序还是要顺序执行，要等待run方法体执行完毕后，才可继续执行下面的代码； 程序中只有主线程——这一个线程， 其程序执行路径还是只有一条， 这样就没有达到写线程的目的。
==记住：多线程就是分时利用CPU，宏观上让所有线程一起执行 ，也叫并发==
## Java中CyclicBarrier 和 CountDownLatch有什么不同?
| ---            | --            |
| -------------- | ------------- |
| CountDownLatch | CyclicBarrier |
| 减计数方式   |   加计数方式    |
|  计算为0时释放所有等待的线程   | 计数达到指定值时释放所有等待线程   |
| 计数为0时，无法重置   | 计数达到指定值时，计数置为0重新开始  |
|  调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响  | 调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞   |
| 不可重复利用 | 可重复利用 |
## Java内存模型是什么？
Java内存模型规定和指引Java程序在不同的内存架构、CPU和操作系统间有确定性地行为。它在多线程的情况下尤其重要。Java内存模型对一个线程所做的变动能被其它线程可见提供了保证，它们之间是先行发生关系。这个关系定义了一些规则让程序员在并发编程时思路更清晰。比如，先行发生关系确保了
- 线程内的代码能够按先后顺序执行，这被称为程序次序规则。
- 对于同一个锁，一个解锁操作一定要发生在时间上后发生的另一个锁定操作之前，也叫做管程锁定规则。
- 前一个对volatile的写操作在后一个volatile的读操作之前，也叫volatile变量规则。
- 一个线程内的任何操作必需在这个线程的start()调用之后，也叫作线程启动规则。
- 一个线程的所有操作都会在线程终止之前，线程终止规则。
- 一个对象的终结操作必需在这个对象构造完成之后，也叫对象终结规则。
- 可传递性
## Java中的valatile变量是什么？
- 可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。
- Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。
- 当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。
- 当一个变量定义为 volatile 之后，将具备两种特性：保证此变量对所有的线程的可见性;禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。
### 五个使用valatile的场景
synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：
- 对变量的写操作不依赖于当前值
- 该变量没有包含在具有其他变量的不变式中
==上述2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。==
**下面列举几个Java中使用valatile的几个场景：**
1. 状态标志
状态标志实现volatile变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。
```Java
public class Test01 {
    volatile boolean shutdownRequested;
    public void shutdown() {
        shutdownRequested = true;
    }

    public void doWork() {
        while (!shutdownRequested) {
            //dostuff
        }
    }
}
```
2. 一次性安全发布
缺乏同步会导致无法实现可见性，这使得确定何时写入对象引用而不是原语值变得更加困难。在缺乏同步的情况下，可能会遇到某个对象引用的更新值（由另一个线程写入）和该对象状态的旧值同时存在。（这就是造成著名的双重检查锁定（double-checked-locking）问题的根源，其中对象引用在没有同步的情况下进行读操作，产生的问题是您可能会看到一个更新的引用，但是仍然会通过该引用看到不完全构造的对象）。
```Java
public class BackgroundFloobleLoader{
    public volatile Flooble theFlooble;
    public void initInBackground(){
        //dolotsofstuff
        theFlooble = new Flooble();
        //this is the only write to theFlooble
    }
}

public class SomeOtherClass{
    public void doWork(){
        while(true){
            //dosomestuff...
            //usetheFlooble,butonlyifitisready
            if(floobleLoader.theFlooble!=null)
               doSomething(floobleLoader.theFlooble);
        }
    }
}
```
该模式的一个必要条件是：被发布的对象必须是线程安全的，或者是有效的不可变对象（有效不可变意味着对象的状态在发布之后永远不会被修改）。volatile 类型的引用可以确保对象的发布形式的可见性，但是如果对象的状态在发布后将发生更改，那么就需要额外的同步
3. 独立观察
```Java
public class UserManager{
    public volatile String lastUser;
    public boolean authenticate(String user, String password){
      // 密码验证
        boolean valid = passwordIsValid(user, password);
        if(valid){
            User u = new User();
            activeUsers.add(u);
            lastUser = user;
        }
        return valid;
    }
}
```
该模式是前面模式的扩展；将某个值发布以在程序内的其他地方使用，但是与一次性事件的发布不同，这是一系列独立事件。这个模式要求被发布的值是有效不可变的 —— 即值的状态在发布后不会更改。使用该值的代码需要清楚该值可能随时发生变化
4. “volatile bean” 模式
volatile bean 模式适用于将 JavaBeans 作为“荣誉结构”使用的框架。在 volatile bean 模式中，JavaBean 被用作一组具有 getter 和/或 setter 方法 的独立属性的容器。volatile bean 模式的基本原理是：很多框架为易变数据的持有者（例如 HttpSession）提供了容器，但是放入这些容器中的对象必须是线程安全的。
在 volatile bean 模式中，JavaBean 的所有数据成员都是 volatile 类型的，并且 getter 和 setter 方法必须非常普通 —— 除了获取或设置相应的属性外，不能包含任何逻辑。此外，对于对象引用的数据成员，引用的对象必须是有效不可变的。（这将禁止具有数组值的属性，因为当数组引用被声明为 volatile 时，只有引用而不是数组本身具有 volatile 语义）。对于任何 volatile变量，不变式或约束都不能包含 JavaBean 属性。
```Java
@ThreadSafe
public class Person{

    private volatile String firstName;
    private volatile String lastName;
    private volatile intage;

    public String getFirstName(){
        return firstName;
    }

    public String getLastName(){
        return lastName;
    }

    public int getAge(){
        return age;
    }

    public void setFirstName(String firstName){
        this.firstName = firstName;
    }

    public void setLastName(String lastName){
        this.lastName = lastName;
    }

    public void setAge(int age){
        this.age = age;
    }
}
```
==volatile 的高级模式：==
- 前面几节介绍的模式涵盖了大部分的基本用例，在这些模式中使用 volatile 非常有用并且简单。这一节将介绍一种更加高级的模式，在该模式中，volatile 将提供性能或可伸缩性优势。
volatile 应用的的高级模式非常脆弱。因此，必须对假设的条件仔细证明，并且这些模式被严格地封装了起来，因为即使非常小的更改也会损坏您的代码！同样，使用更高级的 volatile 用例的原因是它能够提升性能，确保在开始应用高级模式之前，真正确定需要实现这种性能获益。需要对这些模式进行权衡，放弃可读性或可维护性来换取可能的性能收益 —— 如果您不需要提升性能（或者不能够通过一个严格的测试程序证明您需要它），那么这很可能是一次糟糕的交易，因为您很可能会得不偿失，换来的东西要比放弃的东西价值更低。
5. 开销较低的读－写锁策略
目前为止，您应该了解了 volatile 的功能还不足以实现计数器。因为 ++x 实际上是三种操作（读、添加、存储）的简单组合，如果多个线程凑巧试图同时对 volatile 计数器执行增量操作，那么它的更新值有可能会丢失。
然而，如果读操作远远超过写操作，您可以结合使用内部锁和 volatile变量来减少公共代码路径的开销。清单 6 中显示的线程安全的计数器使用 synchronized 确保增量操作是原子的，并使用 volatile 保证当前结果的可见性。如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及 volatile 读操作，这通常要优于一个无竞争的锁获取的开销。
```Java
@ThreadSafe
public class CheesyCounter{
    //Employs the cheap read-write lock trick
    //All mutative operations MUST be done with the 'this' lock held
    @GuardedBy("this")
    private volatile int value;
        public int getValue(){
        return value;
    }

    public synchronized int increment(){
        return value++;
    }
}
```
之所以将这种技术称之为 “开销较低的读－写锁” 是因为您使用了不同的同步机制进行读写操作。因为本例中的写操作违反了使用 volatile 的第一个条件，因此不能使用 volatile 安全地实现计数器 —— 您必须使用锁。然而，您可以在读操作中使用 volatile 确保当前值的可见性，因此可以使用锁进行所有变化的操作，使用 volatile 进行只读操作。其中，锁一次只允许一个线程访问值，volatile 允许多个线程执行读操作，因此当使用 volatile 保证读代码路径时，要比使用锁执行全部代码路径获得更高的共享度 —— 就像读－写操作一样。然而，要随时牢记这种模式的弱点：如果超越了该模式的最基本应用，结合这两个竞争的同步机制将变得非常困难。
==总结：==
与锁相比，Volatile变量是一种非常简单但同时又非常脆弱的同步机制，它在某些情况下将提供优于锁的性能和伸缩性。如果严格遵循 volatile 的使用条件 —— 即变量真正独立于其他变量和自己以前的值 —— 在某些情况下可以使用 volatile 代替 synchronized 来简化代码。然而，使用 volatile 的代码往往比使用锁的代码更加容易出错。本文介绍的模式涵盖了可以使用 volatile 代替 synchronized 的最常见的一些用例。遵循这些模式（注意使用时不要超过各自的限制）可以帮助您安全地实现大多数用例，使用 volatile变量获得更佳性能。
## 什么是线程安全？Vector是一个线程安全类吗？
如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。
## Java中什么是竞态条件？ 举个例子说明。
当某个计算正确性取决于多个线程的交替执行时序时, 就会发生静态条件,即争取的结果要取决于运气, 最常见的静态条件就是"先检查后执行",通过一个可能失效的观测结果来决定下一步的动作.
```Java
class Counter {
    protected long count = 0;
    public void add(long value) {
        this.count = this.count + value;
    }
}
```
观察线程A和B交错执行会发生什么，两个线程分别加了2和3到count变量上，两个线程执行结束后count变量的值应该等于5。然而由于两个线程是交叉执行的，两个线程从内存中读出的初始值都是0。然后各自加了2和3，并分别写回内存。最终的值并不是期望的5，而是最后写回内存的那个线程的值，上面例子中最后写回内存的是线程A，但实际中也可能是线程B。如果没有采用合适的同步机制，线程间的交叉执行情况就无法预料。
add()方法就是一个临界区,它会产生竞态条件。
## 一个线程允许时异常会怎样？
1. 如果该异常被捕获或抛出，则程序继续运行。
2. 如果异常没有被捕获该线程将会停止执行
Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler，并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理。
## 线程间如何通信,进程间如何通信?
1. 共享变量
2. wait，notify机制
3. Lock/Condition机制
4. 管道机制,创建管道输出流PipedOutputStream pos和管道输入流PipedInputStream pis,将pos和pis匹配，pos.connect(pis),将pos赋给信息输入线程，pis赋给信息获取线程，就可以实现线程间的通讯了.
==管道流虽然使用起来方便，但是也有一些缺点：==
1. 管道流只能在两个线程之间传递数据
线程consumer1和consumer2同时从pis中read数据，当线程producer往管道流中写入一段数据后，每一个时刻只有一个线程能获取到数据，并不是两个线程都能获取到producer发送来的数据，因此一个管道流只能用于两个线程间的通讯。不仅仅是管道流，其他IO方式都是一对一传输。
2. 管道流只能实现单向发送，如果要两个线程之间互通讯，则需要两个管道流.
1). 管道（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。
2). 命名管道（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关 系 进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。
3). 信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送 信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。
4). 消息（Message）队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺。
5). 共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。
6). 内存映射（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。
7). 信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。
8). 套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。
## Java中notify 和 notifyAll有什么区别？
notify()&notifyall()的共同点：均能唤醒正在等待的线程，并且均是最后只有一个线程获取资源对象的锁。
==不同点：==notify() 只能唤醒一个线程，而notifyall()能够唤醒所有的线程，当线程被唤醒以后所有被唤醒的线程竞争获取资源对象的锁，其中只有一个能够得到对象锁，执行代码。
==注意：==wait()方法并不是在等待资源的锁，而是在等待被唤醒（notify()），一旦被唤醒后，被唤醒的线程就具备了资源锁（因为无需竞争），直至再次执行wait()方法或者synchronized代码块执行完毕。
## 为什么wait, notify 和 notifyAll这些方法不在thread类里面？
一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。
## 什么是ThreadLocal变量？
ThreadLocal一般称为线程本地变量，它是一种特殊的线程绑定机制，将变量与线程绑定在一起，为每一个线程维护一个独立的变量副本。通过ThreadLocal可以将对象的可见范围限制在同一个线程内。
==跳出误区：==
- 需要重点强调的的是，不要拿ThreadLocal和synchronized做类比，因为这种比较压根就是无意义的！sysnchronized是一种互斥同步机制，是为了保证在多线程环境下对于共享资源的正确访问。而ThreadLocal从本质上讲，无非是提供了一个“线程级”的变量作用域，它是一种线程封闭（每个线程独享变量）技术，更直白点讲，ThreadLocal可以理解为将对象的作用范围限制在一个线程上下文中，使得变量的作用域为“线程级”。
- 没有ThreadLocal的时候，一个线程在其声明周期内，可能穿过多个层级，多个方法，如果有个对象需要在此线程周期内多次调用，且是跨层级的（线程内共享），通常的做法是通过参数进行传递；而ThreadLocal将变量绑定在线程上，在一个线程周期内，无论“你身处何地”，只需通过其提供的get方法就可轻松获取到对象。极大地提高了对于“线程级变量”的访问便利性。
## Java中ThreadLocal变量, volatile变量, synchronized的区别?
- volatile主要是用来在多线程中同步变量。
- 在一般情况下，为了提升性能，每个线程在运行时都会将主内存中的变量保存一份在自己的内存中作为变量副本，但是这样就很容易出现多个线程中保存的副本变量不一致，或与主内存的中的变量值不一致的情况。
而当一个变量被volatile修饰后，该变量就不能被缓存到线程的内存中，它会告诉编译器不要进行任何移出读取和写入操作的优化，换句话说就是不允许有不同于“主”内存区域的变量拷贝，所以当该变量有变化时，所有调用该变量的线程都会获得相同的值，这就确保了该变量在应用中的可视性(当一个任务做出了修改在应用中必须是可视的)，同时性能也相应的降低了(还是比synchronized高)。
- 但需要注意volatile只能确保操作的是同一块内存，并不能保证操作的原子性。所以volatile一般用于声明简单类型变量，使得这些变量具有原子性，即一些简单的赋值与返回操作将被确保不中断。但是当该变量的值由自身的上一个决定时，volatile的作用就将失效，这是由volatile关键字的性质所决定的。
- 所以在volatile时一定要谨慎，千万不要以为用volatile修饰后该变量的所有操作都是原子操作，不再需要synchronized关键字了。
- ThreadLocal是一个线程的局部变量(其实就是一个Map),ThreadLocal会为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。这样做其实就是以空间换时间的方式(与synchronized相反)，以耗费内存为代价，单大大减少了线程同步(如synchronized)所带来性能消耗以及减少了线程并发控制的复杂度。
- synchronized关键字是Java利用锁的机制自动实现的，一般有同步方法和同步代码块两种使用方式。Java中所有的对象都自动含有单一的锁(也称为监视器)，当在对象上调用其任意的synchronized方法时，此对象被加锁(一个任务可以多次获得对象的锁，计数会递增)，同时在线程从该方法返回之前，该对象内其他所有要调用类中被标记为synchronized的方法的线程都会被阻塞。
## 什么是Future，TutureTask?
Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。
Future类位于java.util.concurrent包下，它是一个接口：
```Java
public interface Future<V> {
    boolean cancel(boolean mayInterruptIfRunning);
    boolean isCancelled();
    boolean isDone();
    V get() throws InterruptedException, ExecutionException;
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```
==在Future接口中声明了5个方法，下面依次解释每个方法的作用：==
1. cancel方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true
2. isCancelled方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true
3. isDone方法表示任务是否已经完成，若任务完成，则返回true
4. get()方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回
5. get(long timeout, TimeUnit unit)用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null
==也就是说Future提供了三种功能：==
1. 判断任务是否完成
2. 能够中断任务
3. 能够获取任务执行结果
在Java并发程序中FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对调用了Callable和Runnable的对象进行包装，由于FutureTask也是调用了Runnable接口所以它可以提交给Executor来执行。
## Java中interrupted 和 isInterruptedd方法的区别？
- interrupted() 和 isInterrupted()的主要区别是前者会将中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能被其它线程调用中断来改变。
- interrupt方法是用于中断线程的，调用该方法的线程的状态将被置为"中断"状态。注意：线程中断仅仅是设置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出InterruptedException的方法，比如这里的sleep，以及Object.wait等方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常
- interrupted方法的实现：
```Java
public static boolean interrupted() {  
    return currentThread().isInterrupted(true);  
}
```
- isInterrupted的实现：
```Java
public boolean isInterrupted() {  
    return isInterrupted(false);  
}
```
- 这两个方法一个是static的，一个不是，但实际上都是在调用同一个方法，只是interrupted方法传入的参数为true，而inInterrupted传入的参数为false。这是一个native方法，看不到源码没有关系，参数名字ClearInterrupted已经清楚的表达了该参数的作用----是否清除中断状态。方法的注释也清晰的表达了“中断状态将会根据传入的ClearInterrupted参数值确定是否重置”。所以，静态方法interrupted将会清除中断状态（传入的参数ClearInterrupted为true），而实例方法isInterrupted则不会（传入的参数ClearInterrupted为false）
## Java中volatile和原子类？
- 如果一个变量加了volatile关键字，就会告诉编译器和JVM的内存模型：这个变量是对所有线程共享的、可见的，每次jvm都会读取最新写入的值并使其最新值在所有CPU可见。volatile似乎是有时候可以代替简单的锁，似乎加了volatile关键字就省掉了锁。但又说volatile不能保证原子性（java程序员很熟悉这句话：volatile仅仅用来保证该变量对所有线程的可见性，但不保证原子性）。如果你的字段是volatile，Java内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令。这意味着如果你对一个volatile字段进行写操作，你必须知道：1、一旦你完成写入，任何访问这个字段的线程将会得到最新的值。2、在你写入前，会保证所有之前发生的事已经发生，并且任何更新过的数据值也是可见的，因为内存屏障会把之前的写入值都刷新到缓存。
==volatile为什么没有原子性?==
- 明白了内存屏障（memory barrier）这个CPU指令，回到前面的JVM指令：从Load到store到内存屏障，一共4步，其中最后一步jvm让这个最新的变量的值在所有线程可见，也就是最后一步让所有的CPU内核都获得了最新的值，但中间的几步（从Load到Store）是不安全的，中间如果其他的CPU修改了值将会丢失
- 因为CAS是基于乐观锁的，也就是说当写入的时候，如果寄存器旧值已经不等于现值，说明有其他CPU在修改，那就继续尝试。所以这就保证了操作的原子性。
## 为什么wait和notify方法要在同步块中调用？
主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。还有一个原因是为了避免wait和notify之间产生竞态条件
## Java中的同步集合与并发集合有什么区别(Synchronized VS Concurrent Collections)
- 不管是同步集合还是并发集合他们都支持线程安全，他们之间主要的区别体现在性能和可扩展性，还有他们如何实现的线程安全。同步HashMap, Hashtable, HashSet, Vector, ArrayList 相比他们并发的实现（比如：ConcurrentHashMap, CopyOnWriteArrayList, CopyOnWriteHashSet）会慢得多。造成如此慢的主要原因是锁， 同步集合会把整个Map或List锁起来，而并发集合不会。并发集合实现线程安全是通过使用先进的和成熟的技术像锁剥离。比如ConcurrentHashMap 会把整个Map 划分成几个片段，只对相关的几个片段上锁，同时允许多线程访问其他未上锁的片段。
- 同样的，CopyOnWriteArrayList 允许多个线程以非同步的方式读，当有线程写的时候它会将整个List复制一个副本给它。
- 如果在读多写少这种对并发集合有利的条件下使用并发集合，这会比使用同步集合更具有可伸缩性。
- 同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在Java1.5之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性
## Java中堆和栈有什么不同？
因为栈是一块和线程紧密相关的内存区域。每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的。而堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时volatile 变量就可以发挥作用了，它要求线程从主存中读取变量的值

## 什么是线程池？为什么用它？
- 有时候，系统需要处理非常多的执行时间很短的请求，如果每一个请求都开启一个新线程的话，系统就就要不断的进行线程的销毁，有时华仔创建线程上的时间会比真正执行的时间还长。
- 而且当线程数量太多时，系统不一定受的了。
- 通过重用线程池中的线程，来减少每个线程创建和销毁的性能开销。
- 对线程进行一些维护和管理，比如定时开始，周期执行，并发数控制等等。

## 线程池参数什么意思？
比如去火车站买票，又10个售票窗口，但只有5个窗口对外开放，那么对外开放的5个窗口称为==核心线程数==。而最大线程数是10个窗口。如果5个窗口都被占用，那么后来的人就必须在后面排队，但火车站站长下令。把剩下的5个窗口也打开，也就是目前已经又10个窗口同时运行。后来又来了一批人，10个窗口也处理不过来了，售票厅人已经满了，这时候站长就下令封锁入口，不允许其他人再进来，这就是线程池异常处理策略。而线程池存活时间指的是，允许售票员休息的最长时间，从此限制售票员偷懒的行为。

## 讲一讲线程池中的ThreadPoolExecutor，每个参数都是干什么的？
Executor是一个接口，跟线程池有关的基本都要跟他打交道。ThreadPoolExecutor的关系
![ThreadPoolExecutor](/assets/ThreadPoolExecutor_7lkwiov54.png)
1. corePoolSize：核心线程数
- 默认情况下核心线程会一直存在，即使处于闲置状态也不会受keepAliveTime限制。
- 除非将allowCoreThread设置为true（默认false）时，核心线程会超时关闭
2. maximumPoolSize：最大线程池
- 当线程数>=corePoolSize，且任务队列已满时，线程池会创建新线程来处理任务，
- 当线程数=maxPoolSize，且任务队列已满时，线程池会拒绝处理任务而抛出异常
3. keepAliveTime：线程空闲时间
- 当线程空闲时间达到keepAliveTime时，线程会退出，直到线程数量=corePoolSize
- 如果allowCoreThreadTimeout=true，则会直到线程
4. rejectedExecutionHandler：任务拒绝处理器
==两种情况下为拒绝任务：==
- 当线程数已经达到maxPoolSize，且队列已满，会拒绝新任务
- 当线程池被调用shutdown()后，会等待线程池里的任务执行完毕，再shutdown，如果在调用shutdown()和线程池真正shutdown之间提交任务，会拒绝新任务
5. unit：指定keepAliveTime的单位
- 如TimeUnit.SECONDS，当allowThreadTimeOut设置为true时对corePoolSize生效
6. workQueue：线程池中的任务队列
- 常用的有三种队列，SynchronousQueue，LinkedBlockingDeque，ArrayBlockingQueue
7. threadFactory：线程工厂，提供创建新线程的功能。ThreadFactory时一个接口，只有一个方法
```java
public interface ThreadFactory{
  Thread new Thread(Runnable r);  
}
```
## ThreadPoolExecutor内部使用规则
==线程池的线程执行规则跟任务队列有很大的关系==
==下面都假设任务队列没有大小限制==
- 如果线程数量&lt;=核心线程数量，那么直接启动一个核心线程来执行任务，不会放入队列中
- 如果线程数量>核心线程数，但&lt;=最大线程数，并且任务队列时LinkedBlockingDeque的时候，超过核心线程数量的任务会放在队列中排队
- 如果线程数量>核心线程数，但&lt;=最大线程数，并且任务队列是SynchronousQueue的时候，线程池会创建新线程执行任务，也不会放入任务队列中。这些线程输入非核心线程，在任务完成后，闲置时间达到了超时时间就会被清除。
- 如果线程数量>核心线程数，并且>最大线程数，当任务队列是LinkBlockDeque，会将超过核心线程的任务放在任务队列中，也就是当任务队列是LinkedBlockingDeque并且没有大小限制时，线程池的最大线程数设置是无效的。
- 如果线程数量>核心线程数，并且>最大线程数，当任务队列是SyschronousQueue的时候，会因为线程池拒绝添加任务而抛出 异常
- 当LinkedBlockingDeque塞满时，新增的任务会直接创建新线程来执行，当创建的线程数量超过最大线程数量时会抛异常
- SynchronousQueue没有数量限制。因为它根本不保持这些任务，二十直接交割线程池去执行。当任务数量超过最大线程数时抛出异常
***
## 创建线程的四种方式
### 1. 继承Thread接口
1. 定义Thread类的子类，并重写该类的run()方法，该方法的方法体就是线程需要完成的任务，run()方法也称为线程执行体
2. 创建Thread子类的实例，也就是创建了线程对象
3. 启动线程，即调用线程的start()方法
```Java
package com.thread;

public class TheadTest {
  //调用线程
    public static void main(String[] args) {
        new MyThread().start();
    }
}

// 创建线程
class MyThread extends Thread {

    @Override
    public void run() {
        // 重写run方法
    }
}
```
***
### 2. 实现Runnable接口

1. 定义Runnable接口的实现类，一样要重写run()方法，这个run（）方法和Thread中的run()方法一样是线程的执行体
2. 创建Runnable实现类的实例，并用这个实例作为Thread的target来创建Thread对象，这个Thread对象才是真正的线程对象
3. 第三部依然是通过调用线程对象的start()方法来启动线程

```Java
package com.thread;

public class TheadTest {
    // 调用线程
    public static void main(String[] args) {
        new Thread(new MyThread()).start();
    }
}

// 创建线程
class MyThread implements Runnable{

    @Override
    public void run() {
        // 重写run方法
    }
}
```
***
### 3. 使用Callable和Future创建线程

和Runnable接口不一样，Callable接口提供了一个call（）方法作为线程执行体，call()方法比run()方法功能要强大：

- all()方法可以有返回值
- call()方法可以声明抛出异常
> Java5提供了Future接口来代表Callable接口里call()方法的返回值，并且为Future接口提供了一个实现类FutureTask，这个实现类既实现了Future接口，还实现了Runnable接口，因此可以作为Thread类的target。在Future接口里定义了几个公共方法来控制它关联的Callable任务。！
> 1. boolean cancel(boolean mayInterruptIfRunning)：视图取消该Future里面关联的Callable任务
> 2. V get()：返回Callable里call（）方法的返回值，调用这个方法会导致程序阻塞，必须等到子线程结束后才会得到返回值
> 3. V get(long timeout,TimeUnit unit)：返回Callable里call（）方法的返回值，最多阻塞timeout时间，经过指定时间没有返回抛出TimeoutException
> 4. boolean isDone()：若Callable任务完成，返回True
> 5. boolean isCancelled()：如果在Callable任务正常完成前被取消，返回True
1. 创建Callable接口的实现类，并实现call()方法，然后创建该实现类的实例（从java8开始可以直接使用Lambda表达式创建Callable对象）
2. 使用FutureTask类来包装Callable对象，该FutureTask对象封装了Callable对象的call()方法的返回值
3. 使用FutureTask对象作为Thread对象的target创建并启动线程（因为FutureTask实现了Runnable接口）
4. 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值
- 创建
```Java
package com.thread;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class CallableThreadTest implements Callable<Integer> {
    public static void main(String[] args) {
        CallableThreadTest ctt = new CallableThreadTest();
        FutureTask<Integer> ft = new FutureTask<Integer>(ctt);
        // Thread thread = new Thread(ft,"有返回值的线程");
        // thread.start();
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + " 的循环变量i的值" + i);
            if (i == 20) {
                new Thread(ft, "有返回值的线程").start();
            }
        }
        try {
            System.out.println("子线程的返回值：" + ft.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }

    @Override
    public Integer call() throws Exception {
        int i = 0;
        for (; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + " " + i);
        }
        return i;
    }
}
```
***
### 4. 通过线程池创建线程
1.5后引入的Executor框架的最大优点是把任务的提交和执行解耦。要执行任务的人只需把Task描述清楚，然后提交即可。这个Task是怎么被执行的，被谁执行的，什么时候执行的，提交的人就不用关心了。具体点讲，提交一个Callable对象给ExecutorService（如最常用的线程池ThreadPoolExecutor），将得到一个Future对象，调用Future对象的get方法等待执行结果就好了。Executor框架的内部使用了线程池机制，它在java.util.cocurrent 包下，通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作。因此，在Java 5之后，通过Executor来启动线程比使用Thread的start方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免this逃逸问题——如果我们在构造器中启动一个线程，因为另一个任务可能会在构造器结束之前开始执行，此时可能会访问到初始化了一半的对象用Executor在构造器中。
> - Executor框架包括：线程池，Executor，Executors，ExecutorService，CompletionService，Future，Callable等
> - Executor接口中之定义了一个方法execute(Runnable command)，该方法接收一个Runable实例，它用来执行一个任务，任务即一个实现了Runnable接口的类。ExecutorService接口继承自Executor接口，它提供了更丰富的实现多线程的方法，比如，ExecutorService提供了关闭自己的方法，以及可为跟踪一个或多个异步任务执行状况而生成 Future 的方法。 可以调用ExecutorService的shutdown()方法来平滑地关闭 ExecutorService，调用该方法后，将导致ExecutorService停止接受任何新的任务且等待已经提交的任务执行完成(已经提交的任务会分两类：一类是已经在执行的，另一类是还没有开始执行的)，当所有已经提交的任务执行完毕后将会关闭ExecutorService。因此我们一般用该接口来实现和管理多线程
> - ExecutorService的生命周期包括三种状态：运行、关闭、终止==。创建后便进入运行状态，当调用了shutdown()方法时，便进入关闭状态，此时意味着ExecutorService不再接受新的任务，但它还在执行已经提交了的任务，当素有已经提交了的任务执行完后，便到达终止状态。如果不调用shutdown()方法，ExecutorService会一直处在运行状态，不断接收新的任务，执行新的任务，服务器端一般不需要关闭它，保持一直运行即可。
> - Executors提供了一系列工厂方法用于创先线程池，返回的线程池都实现了ExecutorService接口。   
  1. 创建固定数目线程的线程池。
  public static ExecutorService newFixedThreadPool(int nThreads)
  2.创建一个可缓存的线程池，调用execute将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线 程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。
public static ExecutorService newCachedThreadPool()
  3. 创建一个单线程化的Executor。
public static ExecutorService newSingleThreadExecutor()
  4. 创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类。
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)

**上面这四种方法都是用的Executors中的ThreadFactory建立的线程，下面就以上四个方法做个比较**
| --- | ---                                                                                                                                                                                                                                                        |
| --------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| newCachedThreadPool() | 缓存型池子，先查看池中有没有以前建立的线程，如果有，就 reuse.如果没有，就建一个新的线程加入池中；缓存型池子通常用于执行一些生存期很短的异步型任务因此在一些面向连接的daemon型SERVER中用得不多。但对于生存期短的异步任务，它是Executor的首选。能reuse的线程，必须是timeout IDLE内的池中线程，缺省     timeout是60s,超过这个IDLE时长，线程实例将被终止及移出池。注意，放入CachedThreadPool的线程不必担心其结束，超过TIMEOUT不活动，其会自动被终止 |
|    newFixedThreadPool(int)  | newFixedThreadPool与cacheThreadPool差不多，也是能reuse就用，但不能随时建新的线程；其独特之处:任意时间点，最多只能有固定数目的活动线程存在，此时如果有新的线程要建立，只能放在另外的队列中等待，直到当前的线程中某个线程终止直接被移出池子；和cacheThreadPool不同，FixedThreadPool没有IDLE机制（可能也有，但既然文档没提，肯定非常长，类似依赖上层的TCP或UDP IDLE机制之类的），所以FixedThreadPool多数针对一些很稳定很固定的正规并发线程，多用于服务器；从方法的源代码看，cache池和fixed 池调用的是同一个底层 池，只不过参数不同:fixed池线程数固定，并且是0秒IDLE（无IDLE）；cache池线程数支持0-Integer.MAX_VALUE(显然完全没考虑主机的资源承受能力），60秒IDLE  |
|newScheduledThreadPool(int) | 调度型线程池；这个池子里的线程可以按schedule依次delay执行，或周期执行|
| SingleThreadExecutor() |单例线程，任意时间池中只能有一个线程，用的是和cache池和fixed池相同的底层池，但线程数目是1-1,0秒IDLE（无IDLE）|

一般来说，CachedTheadPool在程序执行过程中通常会创建与所需数量相同的线程，然后在它回收旧线程时停止创建新线程，因此它是合理的Executor的首选，只有当这种方式会引发问题时（比如需要大量长时间面向连接的线程时），才需要考虑用FixedThreadPool。（该段话摘自《Thinking in Java》第四版）

#### Executor执行Runnable任务
通过Executors的以上四个静态工厂方法获得 ExecutorService实例，而后调用该实例的execute(Runnable command)方法即可。一旦Runnable任务传递到execute()方法，该方法便会自动在一个线程上
```Java
package com.thread;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class CachedThreadPool {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newCachedThreadPool();
        // ExecutorService executorService = Executors.newFixedThreadPool(5);
        //ExecutorService executorService = Executors.newSingleThreadExecutor();
        for (int i = 0; i < 5; i++) {
            executorService.execute(new TestRunnable());
            System.out.println("************* a" + i + " *************");
        }
        executorService.shutdown();
    }
}

class TestRunnable implements Runnable {
    public void run() {
        System.out.println(Thread.currentThread().getName() + "线程被调用了。");
    }
}
```
==结果：==
pool-1-thread-1和pool-1-thread-2均被调用了两次，这是随机的，execute会首先在线程池中选择一个已有空闲线程来执行任务，如果线程池中没有空闲线程，它便会创建一个新的线程来执行任务。
#### Executor执行Callable任务
在Java 5之后，任务分两类：一类是实现了Runnable接口的类，一类是实现了Callable接口的类。两者都可以被ExecutorService执行，但是Runnable任务没有返回值，而Callable任务有返回值。并且Callable的call()方法只能通过ExecutorService的submit(Callable<T> task) 方法来执行，并且返回一个 <T>Future<T>，是表示任务等待完成的 Future。
Callable接口类似于Runnable，两者都是为那些其实例可能被另一个线程执行的类设计的。但是 Runnable 不会返回结果，并且无法抛出经过检查的异常而Callable又返回结果，而且当获取返回结果时可能会抛出异常。Callable中的call()方法类似Runnable的run()方法，区别同样是有返回值，后者没有。
当将一个Callable的对象传递给ExecutorService的submit方法，则该call方法自动在一个线程上执行，并且会返回执行结果Future对象。同样，将Runnable的对象传递给ExecutorService的submit方法，则该run方法自动在一个线程上执行，并且会返回执行结果Future对象，但是在该Future对象上调用get方法，将返回null。
下面给出一个Executor执行Callable任务的示例代码：
```Java
package com.thread;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;

public class CallableDemo {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newCachedThreadPool();
        List<Future<String>> resultList = new ArrayList<Future<String>>();

        //创建10个任务并执行
        for (int i = 0; i < 10; i++) {
            //使用ExecutorService执行Callable类型的任务，并将结果保存在future变量中
            Future<String> future = executorService.submit(new TaskWithResult(i));
            //将任务执行结果存储到List中
            resultList.add(future);
        }

        //遍历任务的结果
        for (Future<String> fs : resultList) {
            try {
                while (!fs.isDone()) ;//Future返回如果没有完成，则一直循环等待，直到Future返回完成
                System.out.println(fs.get());     //打印各个线程（任务）执行的结果
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (ExecutionException e) {
                e.printStackTrace();
            } finally {
                //启动一次顺序关闭，执行以前提交的任务，但不接受新任务
                executorService.shutdown();
            }
        }
    }
}

class TaskWithResult implements Callable<String> {
    private int id;
    public TaskWithResult(int id) {
        this.id = id;
    }

    /**
     * 任务的具体过程，一旦任务传给ExecutorService的submit方法，
     * 则该方法自动在一个线程上执行
     */
    public String call() throws Exception {
        System.out.println("call()方法被自动调用！！！    " + Thread.currentThread().getName());
        //该返回结果将被Future的get方法得到
        return "call()方法被自动调用，任务返回的结果是：" + id + "    " + Thread.currentThread().getName();
    }
}
```
==结果：==
submit也是首先选择空闲线程来执行任务，如果没有，才会创建新的线程来执行任务。另外，需要注意：如果Future的返回尚未完成，则get()方法会阻塞等待，直到Future完成返回，可以通过调用isDone()方法判断Future是否完成了返回。
#### 自定义线程池
自定义线程池，可以用ThreadPoolExecutor类创建，它有多个构造方法来创建线程池，用该类很容易实现自定义的线程池，这里先贴上示例程序：
```Java
package com.thread;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class ThreadPoolTest {
    public static void main(String[] args) {
        //创建等待队列
        BlockingQueue<Runnable> bqueue = new ArrayBlockingQueue<Runnable>(20);
        //创建线程池，池中保存的线程数为3，允许的最大线程数为5
        ThreadPoolExecutor pool = new ThreadPoolExecutor(3, 5, 50, TimeUnit.MILLISECONDS, bqueue);
        //创建七个任务
        Runnable t1 = new MyThread();
        Runnable t2 = new MyThread();
        Runnable t3 = new MyThread();
        Runnable t4 = new MyThread();
        Runnable t5 = new MyThread();
        Runnable t6 = new MyThread();
        Runnable t7 = new MyThread();
        //每个任务会在一个线程上执行
        pool.execute(t1);
        pool.execute(t2);
        pool.execute(t3);
        pool.execute(t4);
        pool.execute(t5);
        pool.execute(t6);
        pool.execute(t7);
        //关闭线程池
        pool.shutdown();
    }
}

class MyThread implements Runnable {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + "正在执行。。。");
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```
==结果：==
七个任务是在线程池的三个线程上执行的。这里简要说明下用到的ThreadPoolExecuror类的构造方法。
### 四种创建线程方法对比
实现Runnable和实现Callable接口的方式基本相同，不过是后者执行call()方法有返回值，后者线程执行体run()方法无返回值，因此可以把这两种方式归为一种这种方式与继承Thread类的方法之间的差别如下：
1. 线程只是实现Runnable或实现Callable接口，还可以继承其他类。
2. 这种方式下，多个线程可以共享一个target对象，非常适合多线程处理同一份资源的情形。
3. 但是编程稍微复杂，如果需要访问当前线程，必须调用Thread.currentThread()方法。
4. 继承Thread类的线程类不能再继承其他父类（Java单继承决定）。
5. 前三种的线程如果创建关闭频繁会消耗系统资源影响性能，而使用线程池可以不用线程的时候放回线程池，用的时候再从线程池取，项目开发中主要使用线程池
==注：在前三种中一般推荐采用实现接口的方式来创建多线程==
## 有没有使用过线程并发库？
## 什么是死锁？如何避免死锁？
死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件：
1. 互斥条件：一个资源每次只能被一个进程使用
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
3. 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺
4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系
避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁
## Java中活锁与死锁有什么区别？
活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者进程的状态可以改变但是却不能继续执行
## 怎样检测一个线程是否拥有锁？
在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁
## JVM中哪个参数是用来控制线程的栈堆栈小的？
-Xss参数用来控制线程的堆栈大小
## Java中synchronized 和 ReentrantLock 有什么不同？
==相似点：==
这两种同步方式有很多相似之处，它们都是加锁方式同步，而且都是阻塞式的同步，也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待，而进行线程阻塞和唤醒的代价是比较高的（操作系统需要在用户态与内核态之间来回切换，代价很高，不过可以通过对锁优化进行改善）
==区别：==
- 这两种方式最大区别就是对于Synchronized来说，它是java语言的关键字，是原生语法层面的互斥，需要jvm实现。而ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合try/finally语句块来完成。
- Synchronized进过编译，会在同步块的前后分别形成monitorenter和monitorexit这个两个字节码指令。在执行monitorenter指令时，首先要尝试获取对象锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计算器加1，相应的，在执行monitorexit指令时会将锁计算器就减1，当计算器为0时，锁就被释放了。如果获取对象锁失败，那当前线程就要阻塞，直到对象锁被另一个线程释放为止。
- 由于ReentrantLock是java.util.concurrent包下提供的一套互斥锁，相比Synchronized，ReentrantLock类提供了一些高级功能，主要有以下3项：
> 1. 等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized来说可以避免出现死锁的情况。
> 2. 公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized锁非公平锁，ReentrantLock默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。
> 3. 锁绑定多个条件，一个ReentrantLock对象可以同时绑定对个对象
## 有三个线程T1，T2，T3，怎么确保它们按顺序执行？
在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成。
## Thread类中的yield方法有什么作用？
yield()方法可以让当前正在执行的线程暂停，但它不会阻塞该线程，它只是将该线程从运行状态转入就绪状态。
只是让当前的线程暂停一下，让系统的线程调度器重新调度一次。
很有可能，当某个线程调用了yield()方法暂停之后进入就绪状态，它又马上抢占了CPU的执行权，继续执行。
实际上，当某个线程调用了yield()方法暂停之后，只有优先级与当前线程相同，或者优先级比当前线程更高的处于就绪状态的线程才会获得执行的机会。
## 关于sleep和yield的区别？
1. sleep()方法暂停当前线程后，会给其他线程执行机会，线程优先级对此没有影响。yield()方法会给优先级相同或更高的线程更高的执行机会
2. .sleep()方法会将线程转入阻塞状态，直到阻塞时间结束，才会转入就绪状态。yield()方法会将当前线程直接转入就绪状态
3. sleep()方法声明抛出了InterruptedException异常，所以调用sleep()方法时要么捕捉该异常，要么显示声明抛出该异常。yield()方法则没有声明抛出任何异常
4. sleep()方法比yield()方法有更好的移植性，通常不建议使用yield()方法来控制并发线程的执行
## Java中Semaphore是什么？
Java中的Semaphore是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore只对可用许可的号码进行计数，并采取相应的行动。信号量常常用于多线程的代码中，比如数据库连接池。
## 如果你提交任务时，线程池队列已满。会时发会生什么？
如果一个任务不能被调度执行那么ThreadPoolExecutor’s submit()方法将会抛出一个RejectedExecutionException异常
## Java线程池中submit() 和 execute()方法有什么区别？
1.对返回值的处理不同
execute方法不关心返回值。
submit方法有返回值，Future.
2.对异常的处理不同
excute方法会抛出异常。
sumbit方法不会抛出异常。除非你调用Future.get()
## 什么是阻塞式方法？
阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。
## Swing是线程安全的吗？ 为什么？
Swing不是线程安全的，但是你应该解释这么回答的原因即便面试官没有问你为什么。当我们说swing不是线程安全的常常提到它的组件，这些组件不能在多线程中进行修改，所有对GUI组件的更新都要在AWT线程中完成，而Swing提供了同步和异步两种回调方法来进行更新。
## Java中invokeAndWait 和 invokeLater有什么区别？
- invokeAndWait:后面的程序必须等这个线程(参数中的线程)的东西执行完才能执行
- invokeLater:后面的程序和这个参数的线程对象可以并行,异步地执行
invokeLater一般用于在线程里修改swing组件的外观,因为swing组件是非同步的,所以不能在线程中直接修改,会不同步,得不到期望的效果,所以要把修改外观的代码放在一个单独的线程中,交给invokeLater:后面的程序和这个参数的线程对象可以并行,异步地执行.
## Swing API中那些方法是线程安全的？
这个问题又提到了swing和线程安全，虽然组件不是线程安全的但是有一些方法是可以被多线程安全调用的，比如repaint(), revalidate()。 JTextComponent的setText()方法和JTextArea的insert() 和 append() 方法也是线程安全的。
## 如何在Java中创建Immutable(不可变)对象？
Immutable对象可以在没有同步的情况下共享，降低了对该对象进行并发访问时的同步化开销。可是Java没有@Immutable这个注解符，要创建不可变类，要实现下面几个步骤：通过构造方法初始化所有成员、对变量不要提供setter方法、将所有的成员声明为私有的，这样就不允许直接访问这些成员、在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝
## Java中的ReadWriteLock是什么？
Java中的ReadWriteLock是Java 5 中新增的一个接口，一个ReadWriteLock维护一对关联的锁，一个用于只读操作一个用于写。在没有写线程的情况下一个读锁可能会同时被多个读线程持有。写锁是独占的，你可以使用JDK中的ReentrantReadWriteLock来实现这个规则，它最多支持65535个写锁和65535个读锁。
## 多线程中的忙循环是什么？
忙循环就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了
## 如果同步块内的线程抛出异常会发生什么？
无论你的同步块是正常还是异常退出的，里面的线程都会释放锁
## 单例模式的双检锁是什么？
```java
public static Singleton getInstance() {
  if (instance == null) {
    synchronized(Singleton.class) {  //1
      if (instance == null)          //2
        instance = new Singleton();  //3
    }
  }
  return instance;
}
```
双重检查锁定背后的理论是：在 //2 处的第二次检查使（如清单 3 中那样）创建两个不同的 Singleton 对象成为不可能。假设有下列事件序列：
1. 线程 1 进入 getInstance() 方法
2. 由于 instance 为 null，线程 1 在 //1 处进入 synchronized 块
3. 线程 1 被线程 2 预占
4. 线程 2 进入 getInstance() 方法
5. 由于 instance 仍旧为 null，线程 2 试图获取 //1 处的锁。然而，由于线程 1 持有该锁，线程 2 在 //1 处阻塞
6. 线程 2 被线程 1 预占
7. 线程 1 执行，由于在 //2 处实例仍旧为 null，线程 1 还创建一个 Singleton 对象并将其引用赋值给 instance
8. 线程 1 退出 synchronized 块并从 getInstance() 方法返回实例
9. 线程 1 被线程 2 预占
10. 线程 2 获取 //1 处的锁并检查 instance 是否为 null
11. 由于 instance 是非 null 的，并没有创建第二个 Singleton 对象，由线程 1 创建的对象被返回。
双重检查锁定背后的理论是完美的。不幸地是，现实完全不同。双重检查锁定的问题是：并不能保证它会在单处理器或多处理器计算机上顺利运行
双重检查锁定失败的问题并不归咎于 JVM 中的实现 bug，而是归咎于 Java 平台内存模型。内存模型允许所谓的“无序写入”，这也是这些习语失败的一个主要原因
==无序写入：==
为解释该问题，需要重新考察上述清单 4 中的 //3 行。此行代码创建了一个 Singleton 对象并初始化变量 instance 来引用此对象。这行代码的问题是：在 Singleton 构造函数体执行之前，变量 instance 可能成为非 null 的。
## 写出3条你遵循的多线程最佳实践
- 给你的线程起个有意义的名字。这样可以方便找bug或追踪。OrderProcessor, QuoteProcessor or TradeProcessor 这种名字比 Thread-1. Thread-2 and Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践
- 避免锁定和缩小同步的范围。锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。
- 多用同步类少用wait 和 notify。首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的JDK中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化
- 多用并发集合少用同步集合。这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到map，你应该首先想到用ConcurrentHashMap
## Java中的fork join框架是什么？
fork join框架是JDK7中出现的一款高效的工具，Java开发人员可以通过它充分利用现代服务器上的多处理器。它是专门为了那些可以递归划分成许多子模块设计的，目的是将所有可用的处理能力用来提升程序的性能。fork join框架一个巨大的优势是它使用了工作窃取算法，可以完成更多任务的工作线程可以从其它线程中窃取任务来执行
## Java多线程中调用wait() 和 sleep()方法有什么不同？
Java程序中wait 和 sleep都会造成某种形式的暂停，它们可以满足不同的需要。wait()方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁，而sleep()方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁
***
## 用程序实现两个线程交替打印 0~100 的奇偶数
```java
public class Main {
    private static int count = 0;
    private static final Object lock = new Object();

    public static void main(String[] args) {
        Thread even = new Thread(() -> {
            while (count < 100) {
                synchronized (lock) {
                    // 只处理偶数
                    if ((count & 1) == 0) {
                        System.out.println(Thread.currentThread().getName() + ": " + count++);
                    }
                }
            }
        }, "偶数");
        Thread odd = new Thread(() -> {
            while (count < 100) {
                synchronized (lock) {
                    // 只处理奇数
                    if ((count & 1) == 1) {
                        System.out.println(Thread.currentThread().getName() + ": " + count++);
                    }
                }
            }
        }, "奇数");
        even.start();
        odd.start();
    }
}
```
